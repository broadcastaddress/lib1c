/////////////////////////////////////////////////////////////////////////////
// DISCLAMER:
// This is adapted port of Database class of `couchdb-python` project
// http://code.google.com/p/couchdb-python/
// Author: Christopher Lenz
//
/////////////////////////////////////////////////////////////////////////////

var _name export;
var _resource export;

/////////////////////////////////////////////////////////////////////////////

//function init()
//  Инициализация объекта
//
//    Возвращает:
//      thisoform
//
function init(url,name,session=undefined) export
    if typeof(url)=type("string") then
        _resource=couchdb.Resource(url,session);
    else
        _resource=url;
    endif;
    _name=name;
    return thisform;
endfunction

/////////////////////////////////////////////////////////////////////////////

//function exists()
//  Проверяет существование базы на сервере
//
//    Возвращает:
//      <boolean>
//
function exists() export
    try
        _resource.head();
        return True;
    except
        return False;
    endtry
endfunction

/////////////////////////////////////////////////////////////////////////////

//function repr()
//  Возвращает строковое представление объекта базы
//
//    Возвращает:
//      <string>
//
function repr() export
    return "<Database "+_name+">";
endfunction

/////////////////////////////////////////////////////////////////////////////

//function count()
//  Возвращает количество документов в базе
//
//    Возвращает:
//      <number>
//
function count() export
    return _resource.get_json().data["doc_count"];
endfunction

/////////////////////////////////////////////////////////////////////////////

//function get(id,defalut=undefined,options=undefined)
//  Возвращает данные документа по его id
//
//    Параметры:
//      id <string> -- id документа
//
//    Возвращает:
//      <map>
//
function get(id,default=undefined,options=undefined) export
    try
        return _resource.get_json(id,undefined,options).data;
    except
        err=exception.catch(errorinfo());
        if err.type="ResourceNotFound" then
            return default;
        endif;
        raise;
    endtry;
endfunction

/////////////////////////////////////////////////////////////////////////////

//function set(id,data)
//  Создает/обновляет документ по id
//
//    Параметры:
//        id <string> -- id документа
//      data <structure>, <map> -- данные документа
//
//    Возвращает:
//      data
//
//    Описание:
//      Если data содержит атрибут _rev, то будет произведено
//      обновление документа, иначе будет попыка его создать.
//
//      По завершению операции, обновляет ключи _id и _rev у data.
//
function set(id,data) export
    if not has(id) then
        data.insert("_id",id);
        res=_resource.post_json(undefined,data);
    else
        res=_resource.put_json(id,data);
    endif;
    data.insert("_id",res.data["id"]);
    data.insert("_rev",res.data["rev"]);
    return data;
endfunction

/////////////////////////////////////////////////////////////////////////////

//function del(id)
//  Удаляет документ из базы
//
//    Параметры:
//      id <string> -- id документа
//
//    Возвращает:
//      True - как знак успеха операции.
//
function del(id) export
    doc=get(id);
    if doc=undefined then
        env=new Structure("id",id);
        raise exception.ValueError("Document with this id doesn't exists",env);
    endif;
    _resource.delete_json(doc["_id"],undefined,new Structure("rev",doc["_rev"]));
    return True;
endfunction

/////////////////////////////////////////////////////////////////////////////

//function has(id)
//  Проверяет наличие документа по id в базе
//
//    Параметры:
//      id <string> -- id документа
//
//    Исключения:
//      Любая ошибка, кроме ResourceNotFound.
//
//    Возвращает:
//      <boolean>
//
function has(id) export
    try
        _resource.head(id);
        return True;
    except
        err=exception.catch(errorInfo());
        if err.type="ResourceNotFound" then
            return False;
        else
            raise;
        endif;
    endtry;
endfunction

/////////////////////////////////////////////////////////////////////////////

//function load(id,defalut=undefined,options=undefined)
//  Возвращает документ по его id
//
//    Параметры:
//      id <string> -- id документа
//
//    Возвращает:
//      <CouchDB.Forms.IDocument(<CouchDB.Forms.Document>)>
//
function load(id,default=undefined,options=undefined) export
    try
        return couchdb.Document(_resource.get_json(id,undefined,options).data);
    except
        err=exception.catch(errorinfo());
        if err.type="ResourceNotFound" then
            return default;
        endif;
        raise;
    endtry;
endfunction

//function save(doc)
//  Создает документ в базе или обновляет уже существующий.
//
//    Параметры:
//        doc <CouchDB.Forms.IDocument> -- объект документа
//
//    Возвращает:
//      <Array(id,rev)>
//
//    Описание:
//      Если документ не содержит поле _id, то тогда сервер сгененирует
//      свой случайный id и создаст документ. Иначе же поле _id будет
//      использовано для определения идентификатора для создания или обновления
//      докумета. Попытка обновить документ с неправильным или отличным 
//      от текущего полем _rev вызовет исключение ResourceConfict.
//
//      Следует отметить, что лучше предварительно сгенерировать _id документа,
//      поскольку метод POST HTTP-прокотола обязывает повторять запрос в случае
//      если возникли какие-либо неполадки в сети. В таком случае, если оставить
//      генерацию id на стороне сервера, можно создать несколько одинаковых
//      документов с разными id.
//
//      Если нужен произвольный id документа, можно вызвать метод genid() самого
//      документа или установить вручную чере doc.set("_id","someid")
//
//      По завершению создания или обновления документа в базе, у переданного
//      объекта обновляются поля _id и _rev.
//
//      Метод возвращает массив, содержащий новые id и rev.
function save(doc,options=undefined) export
    res=_resource.post_json(undefined,doc.dispatch(),options).data;
    doc.set("_id",res["id"]);
    if res["rev"]<>null then //Not present for batch='ok'
        doc.set("_rev",res["rev"]);
    endif;
    return pair(res["id"],res["rev"]);
endfunction

//function delete(doc)
//  Удаляет документ из базы
//
//    Параметры:
//        doc <CouchDB.Forms.IDocument> -- объект документа
//
//    Возвращает:
//      True как знак успеха операции
//
//    Описание:
//      Является аналогом записи db.del(doc.get("_id")), за тем исключением,
//      что принимает объект документа вместо _id и не производит дополнительный
//      запрос на получение текущей ревизии документа.
function delete(doc,options=undefined) export
    try
        _resource.delete_json(doc.get("_id"),
                              undefined,
                              new Structure("rev",doc.get("_rev")));
    except
        err=exception.catch(errorinfo());
        if err.type="ResourceNotFound" then
            env=new Structure("doc",doc.dispatch());
            raise exception.ValueError("Document doesn't exists",env);
        endif;
        raise
    endtry;
    return True;
endfunction

/////////////////////////////////////////////////////////////////////////////

//function list()
//  Возвращает список документов в базе
//
//    Возвращает:
//      <array>
//
function list() export
    res=new Array();
    for each item in view("_all_docs")["rows"] do
        res.add(item["id"]);
    enddo;
    return res;
endfunction

/////////////////////////////////////////////////////////////////////////////

//function commit()
//  Применяет сделанные изменения в базе
//
//    Описание:
//      Если сервер был сконфигурирован с отложенной записью или
//      предыдущий запрос содержал заголовок `X-Couch-Full-Commit: false`
//      для отключения моментальной записи, этот метод может быть использован
//      для уверенности, что все не записанные данные будут записаны 
//      на физический носитель
//
//      FIXME: омгкакэтовообщеможночитатьаааааааа!
function commit() export
    return _resource.post_json("_ensure_full_commit").data;
endfunction

/////////////////////////////////////////////////////////////////////////////

//function compact(id=undefined)
//  Ужимает базу или индексы документов
//
//    Возвращает:
//      <boolean>
//
//    Описание:
//      Без аргумента будет произведена попытка удалить все старые ревизии
//      документов из базы. С аргументом - будет очищен кэш индекса по всем
//      запросам в дизайне указанного документа.
//
function compact(id=undefined) export
    if id<>undefined then
        return _resource.copy("_compact").post_json(id).data["ok"];
    else
        return _resource.post_json("_compact").data["ok"];
    endif;
endfunction

/////////////////////////////////////////////////////////////////////////////

//function revisions(id,options=undefined)
//  revision("A123241") -> Array(Map({...}),Map({...}),Map({...}))
//
//    Параметры:
//      id <string> -- id документа
//
//    Возвращает:
//      <array>
//
//    Описание:
//      Возвращает все ревизии документа в обратном хронологическом порядке,
//      если такие имеются в наличии
//
function revisions(id) export
    revs=new Array();
    try
        res=_resource.get_json(id,new Structure("revs",True));
    except
        err=exception.catch(errorInfo());
        if err.type="ResourceNotFound" then
            return revs;
        else
            raise;
        endif;
    endtry;
    options=new map();
    startrev=res.data["_revisions"]["start"];
    i=0;
    for each rev in res.data["_revisions"]["ids"] do
        options.insert("rev",string(startrev-i)+"-"+rev);
        revision=thisform.get(id,options);
        if revision=undefined then
            return revs;
        endif;
        revs.add(revision);
        i=i+1;
    enddo;
    return revs;
endfunction

/////////////////////////////////////////////////////////////////////////////

//function ping()
//  Проверяет доступность базы
//
//    Возвращает:
//      <boolean>
//
function ping() export
    try
        _resource.head();
        return True;
    except
        return False;
    endtry;
endfunction

/////////////////////////////////////////////////////////////////////////////

//function info()
//  Возвращает информацию о базе
//
//    Возвращает:
//      <map>
//
function info() export
    res=_resource.get_json();
    _name=res.data["db_name"];
    return res.data;
endfunction

/////////////////////////////////////////////////////////////////////////////

//function delete_attachment(doc,filename)
//  Удаляет прикрепленный файл filename из документа doc
//
//    Параметры:
//           doc <map>,<structure> -- документ
//      filename <string> -- имя прикрепленного файла
//
//    Возвращает:
//      doc с новой ревизией.
//
//    Замечание:
//      Учтите, что переданный документ `doc` должен содержать атрибут `_rev`
function delete_attachment(doc,filename) export
    res=_resource.copy(doc["_id"])
                 .delete_json(filename,
                              undefined,
                              new Structure("rev",doc["_rev"]));
    doc["_rev"]=res.data["rev"];
    return doc;
endfunction

/////////////////////////////////////////////////////////////////////////////

//function get_attachment(id_or_doc,filename,default=undefined)
//  Возвращает прикрепленный файл filename или default, если его нет.
//
//    Параметры:
//      id_or_doc <string>,<map>,<structure> -- id документа или сам документ
//       filename <string> -- имя прикрепленного файла
//        default <any> -- возвращаемое значение в случае отсутствия 
//                         файла или документа
//    Возвращает:
//      <binarydata>
function get_attachment(id_or_doc,filename,default=undefined) export
    id=?(typeof(id_or_doc)=type("string"),id_or_doc,id_or_doc["_id"]);
    try
        return xmlvalue(type("binarydata"),
                        _resource.copy(id).get(filename).data);
    except
        err=exception.catch(errorInfo());
        if err.type="ResourceNotFound" then
            return default;
        endif;
        raise;
    endtry;
endfunction

/////////////////////////////////////////////////////////////////////////////

//function put_attachment(doc,content,filename=undefined,content_type=undefined)
//  Прикрепляет данные content к документу doc с именем filename.
//
//    Параметры:
//               doc -- <map>,<structure> объект документа
//           content -- <string>,<binarydata> файл или путь к нему
//          filename -- <string> имя файла в документе
//      content_type -- <string> ручная установка MIME-тип данных,
//                      по умолчанию угадывается по расширению файла
//
//    Возвращает:
//      True - как знак успеха операции
//
//    Замечание:
//      Учтите, переданный документ `doc` должен содержать поле `_rev`.
function put_attachment(doc,content,filename=undefined,
                        content_type=undefined) export
    raise exception.NotImplementedError("Need to provide raw access to file not to encoded one");
    if typeof(content)=type("binarydata") then
        data=xmlstring(content);
    elsif typeof(content)=type("string") then
        data=xmlstring(new binarydata(content));
    else
        raise exception.TypeError(
            "Binary data expected or path to file",
            new Structure(doc,content,filename,content_type)
        );
    endif;
    if filename=undefined then
        filename=content.name;
    endif;
    if content_type=undefined then
        //
    endif;
    res=_resource.copy(doc["_id"])
                 .put_json(filename,
                           content,
                           new Structure("Content-Type",content_type),
                           new Structure("rev",doc["_rev"]));
    doc["_rev"]=res.data["rev"];
    return doc;
endfunction

// Not Implemented
function query(map_func,reduce_fun=undefined,lang="javascript",wrapper=undefined)
    raise exception.NotImplementedError();
endfunction

function update(docs,atomic=False) export
    if not check.is_array_or_fixedarray(docs) then
        msg="Invalid `docs` type. Expected array.";
        raise exception.TypeError(msg,new Structure("docs,atomic",
                                                     docs,atomic));
    endif;
    for each doc in docs do
        if not check.is_structure_or_map(doc) then
            msg="Invalid `docs` item type. Expected structure or map.";
            raise exception.TypeError(msg,new Structure("docs,atomic",
                                                         docs,atomic));
        endif;
    enddo;
    content=new Structure("all_or_nothing,docs",atomic,docs);
    results=new Array();
    res=_resource.post_json("_bulk_docs",content);
    i=0;
    for each result in res.data do
        if result.get("error")<>undefined then
            arr=new Array();
            arr.add(False);
            arr.add(result["id"]);
            arr.add(result["error"]+": "+result["reason"]);
            results.add(arr);
        else
            arr=new Array();
            arr.add(True);
            arr.add(result["id"]);
            arr.add(result["rev"]);
            results.add(arr);
            // Is this a good idea?
            docs[i]["_id"]=result["id"];
            docs[i]["_rev"]=result["rev"];
        endif;
        i=i+1;
    enddo;
    return results;
endfunction

// Execute a predefined view.
function view(val name,wrapper=undefined,options=undefined) export
    if not string.startswith(name,"_") then
        l=string.split(name,"/",1);
        design=l[0];
        name=l[1];
        name="_design/"+design+"/_view/"+name;
    endif;
    return couchdb.PermView(
                    _resource.copy(string.split(name,"/")),
                    name,
                    wrapper).exec(options);
endfunction